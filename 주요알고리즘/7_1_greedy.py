'''
■ 그리디

1. 개념
  - 현재 차례의 최고의 답을 찾는 문제
  - 어려운 이유 : 왜그런지 증명하기가 어려움
  - 예시 : 다른 금액의 동전이 여러개 주어졌을때 M원을 만드는 최소의 개수

2. 아이디어
  - 큰 금액의 동전부터 차감
  - 반례 : 동전의 개수가 무한대라서 없는 것으로 보임
  - K를 동전 금액으로 나눈 뒤 남은 값으로 갱신

3. 시간복잡도
  - for : N > O(N)
  
4. 기본 문제
  - 백준 11047 동전 0
  - https://www.acmicpc.net/problem/11047
  - 문제
    준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.
    동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.
      
  - 입력 
    첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
    둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. 
    (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

  - 출력
    첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

  - 예제 입력 1
    10 4200
    1
    5
    10
    50
    100
    500
    1000
    5000
    10000
    50000
      
  - 예제 출력 1
    6
    
  - 예제 입력 2
    10 4790
    1
    5
    10
    50
    100
    500
    1000
    5000
    10000
    50000
    
  - 예제 출력 2
    12
        
  - 변수
    - 동전 금액 : int[]
      - 최대값 : 1e6 > INT 가능
    - 현재 남은 금액 : int
      - 최대값 : 1e8 > INT 가능
    - 동전 개수 : int
      - 최대값 : 1e8 > INT 가능

  - 문제 풀이
    1. 아이디어
      - 동전을 저장한 뒤, 반대로 뒤집음
      - 동전을 for문으로
        - 동전 사용개수 추가
        - 동전 사용한 만큼 K값 갱신
    
    2. 시간복잡도
      - O(N)

    3. 변수
      - 동전 금액 : int[]
      - 동전 사용 cnt : int
      - 남은 금액 : int
      
6. Tip
  - 실전 문제에서 그리디로 푸는 문제임을 생각하기가 어려움
  - 그리디 사용 이유 설명 or 반례 찾기 연습

'''
  
import sys
  
input = sys.stdin.readline

N, K = map(int, input().split())
coins = [int(input()) for _ in range(N)]

coins.reverse()
cnt = 0

for each_coin in coins:
  cnt += K // each_coin
  K = K % each_coin
  
print(cnt)