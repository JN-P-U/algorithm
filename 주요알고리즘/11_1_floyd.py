'''
■ 플로이드

1. 개념
  - 모든 노드에서 다른 모든 노드까지 가는 최소비용, O(V^3)
  - 다익스트라 : 한 노드에서 다른 모든 노드를 가는 최소 비용, O(ElgV)

2. 작동원리
  - 노드 j -> 노드 i 비용 배열 만들기, 초기값 : INF
  - 간선의 값을 비용 배열에 반영
  - 모든 노드에 대해 해당 노드 거쳐 가서 비용이 작아질 경우 값 갱신
  - 핵심코드
    
    # rs[시작점][도착점]
    
    # 자기 자신으로 가는 것은 0으로 초기화
    
    for i in range(1, n + 1): 
      rs[i][i] = 0
      
    # a,b,c : 시작점, 도착점, 거리(비용)
    
    for i in range(m):
      a,b,c = map(int, input().split())
      rs[a][b] = min(rs[a][b], c)

    # k : 거치는 값
    # j : 시작점
    # i : 도착점
    
    for k in range(1, n + 1):
      for j in range(1, n + 1):
        for i in range(1, n + 1):
          
          # 시작점에서 도착점까지 가는 비용이 중간 지점을 통해서 가는 것보다 크면 중간 지점 통해서 가는 것으로 갱신
          if rs[j][i] > rs[j][k] + rs[k][i]:
            rs[j][i] = rs[j][k] + rs[k][i]

3. 시간복잡도
  - O(V^3)
  - 다익스트라 사용 시 : ElgV * V
    - 1e5 * 10 * 1e2 = 1e8 => 시간 초과 가능성 존재
  - 플로이드 사용 시 : V^3
    - (1e2)^3 = 1^6 => 가능
  
4. 기본 문제
  - 백준 11404 플로이드 
  - https://www.acmicpc.net/problem/11404

  - 문제
    n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 
    각 버스는 한 번 사용할 때 필요한 비용이 있다.
    모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.
 
  - 입력  
    첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 
    그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 
    먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 
    버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 
    시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.
    시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.

  - 출력 
    n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 
    만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

  - 예제 입력 1
    5
    14
    1 2 2
    1 3 3
    1 4 1
    1 5 10
    2 4 2
    3 4 1
    3 5 1
    4 5 3
    3 5 10
    3 1 8
    1 4 2
    5 1 7
    3 4 2
    5 2 4
    
  - 예제 출력 1
    0 2 3 1 4
    12 0 15 2 5
    8 5 0 1 1
    10 7 13 0 3
    7 4 10 6 0
  
  - 변수
    - 거리 배열 : int[][]
      - 플로이드는 거리 배열만 존재
      - 비용 최대 : 1e5 * 1e2 = 1e7 => INT 가능
             
  - 풀이 관련 최종 정리
    1. 아이디어
      - 모든 점에서 모든 점으로 : 플로이드
      - 비용 배열을 INF로 초기화
      - 간선의 비용 대입
      - 거쳐서 비용이 줄어들 경우 => 갱신(for문 3번 사용)
    
    2. 시간복잡도
      - 플로이드 : O(V^3)
      - 1e6 => 가능

    3. 변수
      - 비용 배열 : int[][]

6. Tip
  - 그래프 거리 문제 나올 때
    - 한 점에서 여러 점 문제 : 다익스트라(ElgV)
    - 여러 점에서 여러점 문제 : 플로이드(V^3)
  - 코드가 복잡하므로 연습 필요
  
'''

import sys

input = sys.stdin.readline
INF = sys.maxsize


n = int(input())
m = int(input())
rs = [[INF] * (n + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
  rs[i][i] = 0

for i in range(m):
  a,b,c = map(int, input().split())
  rs[a][b] = min(rs[a][b], c)

for k in range(1, n + 1): # 거치는 값
  for j in range(1, n + 1): # 시작점
    for i in range(1, n + 1): # 도착점
      if rs[j][i] > rs[j][k] + rs[k][i]:
        rs[j][i] = rs[j][k] + rs[k][i]

for j in range(1, n + 1):
  for i in range(1, n + 1):
    if rs[j][i] == INF:
      print(0, end = ' ')
    else:
      print(rs[j][i], end = ' ')
  print()